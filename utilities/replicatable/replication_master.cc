// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include <thread>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>

#include "rocksdb/db.h"
#include "rocksdb/slice.h"
#include "rocksdb/options.h"
#include "gen-cpp/Replication.h"

#include "replication_master.h"


namespace rocksdb {

ReplicationHandler::ReplicationHandler(DB *_db) {
  db = _db;
}

ReplicationHandler::~ReplicationHandler() { }

void ReplicationHandler::Update(std::string& _return, const int64_t _seq) {
  std::unique_ptr<TransactionLogIterator> iter; 
  Status st = _db->GetUpdatesSince(_seq, &iter);
  if(!st.ok()) {
    //throw ReplicationError(1, "Invalid sequence number.");
    // must return error message to client
    return 
  }

  TransactionLogIterator *tlit = iter.get();
  BatchResult bres = tlit->GetBatch();
  WriteBatch *wb   = bres.writeBatchPtr.get();
  _return = wb->Data();
}

Status ReplicationMaster::Open(ReplicationMaster* master, DB* _db, int _port) {
  if(!db) return Status::NotFound("DB must be opened");

  master = new ReplicationMaster(_db, _port);
  return master.StartReplication();
}

ReplicationMaster::ReplicationMaster(DB* _db, int _port) {
  db   = _db;
  port = _port;
}

ReplicationMaster::~ReplicationMaster() {
  StopReplication();
}
    
Status ReplicationMaster::StartReplication() {
  using boost::shared_ptr;
  using namespace apache::thrift;
  
  shared_ptr<ReplicationHandler> handler(new ReplicationHandler(db));
  shared_ptr<TProcessor> 
      processor(new ReplicationProcessor(handler));
  shared_ptr<transport::TServerTransport> 
      serverTransport(new transport::TServerSocket(port));    
  shared_ptr<transport::TTransportFactory> 
      transportFactory(new transport::TBufferedTransportFactory());
  shared_ptr<protocol::TProtocolFactory> 
      protocolFactory(new protocol::TBinaryProtocolFactory());
  shared_ptr<concurrency::ThreadManager> 
      threadManager = concurrency::ThreadManager::newSimpleThreadManager(15);
  shared_ptr<concurrency::PosixThreadFactory> threadFactory = 
      shared_ptr<concurrency::PosixThreadFactory>
      (new concurrency::PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  try {
    threadManager->start();
  } catch (concurrency::InvalidArgumentException e) {
    return Status::InvalidArgument("Thrift threadManager error");
  }

  server = new server::TThreadPoolServer(
      processor, serverTransport, transportFactory, 
      protocolFactory, threadManager);
  auto replication_thread = std::thread(&ReplicationMaster::PeriodicalSync,
                                               std::ref(*this));
  replication_thread.detach();
  return State::OK;
}

void ReplicationMaster::PeriodicalSync() {
  server->serve();
}

void ReplicationMaster::StopReplication() {
  server->stop();
}

} // namespace rocksdb
