// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include <unistd.h>
#include <iostream>
#include <thread>
#include <atomic>

#include <thrift/Thrift.h>
#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TTransportUtils.h>

#include "rocksdb/db.h"
#include "rocksdb/env.h"
#include "rocksdb/slice.h"
#include "rocksdb/options.h"
#include "db/filename.h"
#include "util/crc32c.h"

#include "./gen-cpp/Replication.h"
#include "replication_common.h"
#include "replication_slave.h"

namespace rocksdb {

Status ReplicationSlave::Open(ReplicationSlave** slave, DB* _db,
                              const std::string& _master_host,
                              const int _port) {
  if(!_db) return Status::NotFound("DB must be opened");

  *slave = new ReplicationSlave(_db, _master_host, _port);
  return Status::OK();
}

inline Status ReplicationSlave::DisableFileDeletions(SessionID& session_id) {
  try {
    std::cout << "client:" << client << std::endl;
    client->DisableFileDeletions(session_id);
    std::cout << "client:" << client << std::endl;
  } catch (const ReplicationError& e) {
    return Status::ShutdownInProgress(e.why);
  }
  return Status::OK();
}

inline Status ReplicationSlave::EnableFileDeletions(SessionID& session_id, 
                                                   bool force) {
  bool result;
  try {
    result = client->EnableFileDeletions(session_id, force);
  } catch (const ReplicationError& e) {
    return Status::ShutdownInProgress(e.why);
  }

  if (result) {
    return Status::Incomplete("Fail to enable file deletion");
  } else {
    return Status::OK();
  }
}

inline Status ReplicationSlave::GetLiveFiles(
    std::vector<ReplicationFileInfo>& _return,
    SessionID& session_id,
    bool flush_before_replication) {
 try {
   client->GetLiveFiles(_return, session_id, flush_before_replication);
  } catch (const ReplicationError& e) {
    return Status::ShutdownInProgress(e.why);    
  }
  return Status::OK();
}

inline Status ReplicationSlave::GetLiveWALFiles(
    std::vector<ReplicationFileInfo>& _return,
    SessionID& session_id) {
 try {
   client->GetLiveWALFiles(_return, session_id);
  } catch (const ReplicationError& e) {
    return Status::ShutdownInProgress(e.why);    
  }
  return Status::OK();
}

inline Status ReplicationSlave::GetFileData(ReplicationFileData & _return,
                                            SessionID& session_id,
                                            ReplicationFileInfo& file_info,
                                            int64_t transfer_data_size) {
  try {
    client->GetFileData(_return, session_id, file_info, transfer_data_size);
  } catch (const ReplicationError& e) {
    return Status::ShutdownInProgress(e.why);    
  }
  return Status::OK();
}


Status ReplicationSlave::GetFile(SessionID& session_id,
                                 ReplicationFileInfo& file_info,
                                 int64_t transfer_data_size) {
  Status s;
  int data_size = 0;
  uint32_t checksum_value = 0;
  std::string dst_path = db->GetName() + file_info.src_fname;
  unique_ptr<WritableFile> dst_file;
  EnvOptions env_options;
  env_options.use_mmap_writes = false;
  env_options.use_os_buffer = false;
  s = env->NewWritableFile(dst_path , &dst_file, env_options);
  if (s.ok()) return s;
  
  // fetch data from master db;
  while(data_size < file_info.size) {
    ReplicationFileData data;
    GetFileData(data, session_id, file_info, transfer_data_size);
    if(!s.ok()) {
      return s;
    }

    data_size += data.size;
    checksum_value = crc32c::Extend(checksum_value, data.data.c_str(),
                                    data.size);
    s = dst_file->Append(data.data);
    if (!s.ok()) return s;
  }

  // TODO handle checksum
  if (data_size == file_info.size) {
    return Status::OK();
  } else {
    return Status::Corruption("Invalid File size");
  }
}

Status ReplicationSlave::CreateNewReplication(bool flush_before_replication) {
  Status s;
  SessionID session_id;

  std::cout << "***CreateNewReplication" << std::endl;
  std::cout << "****DisableFileDeletions" << std::endl;
  s = DisableFileDeletions(session_id);
  if (!s.ok()) {
    return s;
  }
  std::cout << "***SessionID" << session_id << std::endl;
  
  std::cout << "****GetLiveFiles" << std::endl;
  std::vector<ReplicationFileInfo> file_info;
  s = GetLiveFiles(file_info, session_id, flush_before_replication);
  if (!s.ok()) {
    return s;
  }

  std::cout << "****GetFile" << std::endl;
  // copy files from master
  for(auto iter = file_info.begin();
      iter != file_info.end();
      ++iter) {
    std::cout << "src_fname:" << iter->src_fname << std::endl;
    std::cout << "size:"     << iter->size << std::endl;
    std::cout << "checksum:" << iter->checksum << std::endl;
    s = GetFile(session_id, *iter, transfer_data_size);
    if (!s.ok()) {
      return s;
    }
  }

  if (!flush_before_replication) {
    std::vector<ReplicationFileInfo> wal_file_info;
    s = GetLiveWALFiles(wal_file_info, session_id);
    if (!s.ok()) {
      return s;
    }

    // copy live WAL files from master
    for(auto iter = wal_file_info.begin();
        iter != wal_file_info.end();
        ++iter) {
      std::cout << "src_fname:" << iter->src_fname << std::endl;
      std::cout << "size:"     << iter->size << std::endl;
      std::cout << "checksum:" << iter->checksum << std::endl;
      s = GetFile(session_id, *iter, transfer_data_size);
      if (!s.ok()) {
        return s;
      }
    }
  }

  s = EnableFileDeletions(session_id, false);
  return s;
}

Status ReplicationSlave::PeriodicalUpdate() { 
  using namespace apache::thrift;

  try {
    while(running.load()) {
      Status s;
      ReplicationFileData fileData;
      SequenceNumber last_seq = db->GetLatestSequenceNumber();

      client->PeriodicalUpdate(fileData, last_seq);
      int64_t new_seq = fileData.position;
      if ((SequenceNumber) new_seq == last_seq) break;;

      std::string data = fileData.data;
      WriteBatch wb = WriteBatch(data);
      s = db->Write(WriteOptions(), &wb);
      if(!s.ok()) {
        std::cout << std::endl;
      }
      std::cout << data << std::endl;
      continue;
    }
  } catch (ReplicationError& e) {
    //running.store(false);
    // TODO handling error
    ;
  } catch (TException& tx) {
    std::cout << "ERROR: " << tx.what() << std::endl;
    StopReplication();
  }
  return Status::OK();
}

Status ReplicationSlave::PeriodicalSync(int sync_interval) {
  while(running) {
    Status st = PeriodicalUpdate();
    if (st.ok()) {
      ;
    } else {
      ;
    }
    usleep(sync_interval);
  }
  return Status::OK();
}

Status ReplicationSlave::StartReplication(int sync_interval,
                                          bool flush_before_replication) {
  using namespace apache::thrift;
  using boost::shared_ptr;
  shared_ptr<transport::TTransport> 
      socket(new transport::TSocket(master_host, port));

  shared_ptr<transport::TTransport> 
      transport_(new transport::TBufferedTransport(socket));
  shared_ptr<protocol::TProtocol>
      protocol(new protocol::TBinaryProtocol(transport_));
  
  client = new ReplicationClient(protocol);
  transport = transport_; 
  running.store(true);

  try {
    Status s;
    transport->open();

    // copy data not in the write-ahead log from master.
    s = CreateNewReplication(flush_before_replication);
    if (!s.ok()) {
      return Status::ShutdownInProgress("could not create new replication");
    }

    // start to syncronize slave with master every sync_interval
    sync_result = std::async(std::launch::async,
                             &ReplicationSlave::PeriodicalSync,
                             this,
                             sync_interval);
  } catch (const TException& tx) {

    return Status::ShutdownInProgress("could not connect to master db");
  }
  return Status::OK();
}

Status ReplicationSlave::StopReplication() {
  running.store(false);
  transport->close();
  return Status::OK();
}

ReplicationSlave::ReplicationSlave()
    : db(nullptr),
      env(nullptr),
      port(0),
      master_host(""),
      running(true),
      client(nullptr),
      transfer_data_size(1048576) {
}

ReplicationSlave::ReplicationSlave(DB* _db, const std::string& _master_host,
                                   const int _port)
    : db(_db),
      env(db->GetEnv()),
      port(_port),
      master_host(_master_host),
      client(),
      transfer_data_size(1048576) {
}

ReplicationSlave::~ReplicationSlave() {
  StopReplication();
  delete db;
}

} // namespace rocksdb
