// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include <thread>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>

#include "rocksdb/db.h"
#include "rocksdb/slice.h"
#include "rocksdb/options.h"
#include "rocksdb/thrift/gen-cpp/Replication.h"

#include "replication_master.h"


namespace rocksdb {

ReplicationHandler::ReplicationHandler(DB *db) {
    _db = db;
}

ReplicationHandler::~ReplicationHandler() { }

void ReplicationHandler::Update(std::string& _return, const int64_t seq) {
    if(!_db) throw ReplicationError(0, "Database@Master is not specified.");

    std::unique_ptr<TransactionLogIterator> iter;
    Status st = _db->GetUpdatesSince(seq, &iter);
    if(!st.ok()) throw ReplicationError(1, "Invalid sequence number.");

    TransactionLogIterator *tlit = iter.get();
    BatchResult bres = tlit->GetBatch();
    WriteBatch *wb   = bres.writeBatchPtr.get();
    //std::cout << seq << ":" << wb->Data() << std::endl;
    _return = wb->Data();
}

ReplicationMaster::ReplicationMaster(DB* db, int port) {
    _port = port;
    _db   = db;
}

ReplicationMaster::~ReplicationMaster() {
    StopReplication();
}

void ReplicationMaster::Sync() {
    _server->serve();
}
    
void ReplicationMaster::StartReplication() {
    boost::shared_ptr<ReplicationHandler> handler(new ReplicationHandler(_db));
    boost::shared_ptr<apache::thrift::TProcessor> processor(new ReplicationProcessor(handler));
    boost::shared_ptr<apache::thrift::transport::TServerTransport> serverTransport(new apache::thrift::transport::TServerSocket(_port));
    boost::shared_ptr<apache::thrift::transport::TTransportFactory> transportFactory(new apache::thrift::transport::TBufferedTransportFactory());
    boost::shared_ptr<apache::thrift::protocol::TProtocolFactory> protocolFactory(new apache::thrift::protocol::TBinaryProtocolFactory());
    boost::shared_ptr<apache::thrift::concurrency::ThreadManager> threadManager = apache::thrift::concurrency::ThreadManager::newSimpleThreadManager(15);
    boost::shared_ptr<apache::thrift::concurrency::PosixThreadFactory> threadFactory = \
        boost::shared_ptr<apache::thrift::concurrency::PosixThreadFactory>(new apache::thrift::concurrency::PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    _server = new apache::thrift::server::TThreadPoolServer(processor, serverTransport, transportFactory, protocolFactory, threadManager);
    std::thread replication_thread = std::thread(&ReplicationMaster::Sync, std::ref(*this));
    replication_thread.detach();
}

Status ReplicationMaster::StopReplication() {
    _server->stop();
    return Status::OK();
}

} // namespace rocksdb
