// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include <cstdio>
#include <cstdlib>
#include <string>
#include <iostream>
#include <thread>
#include <memory>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>

#include "gen-cpp/Replication.h"
#include "rocksdb/db.h"
#include "rocksdb/slice.h"
#include "rocksdb/options.h"

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;

using namespace  rocksdb;
using boost::shared_ptr;

class ReplicationSlave {
private:
    DB *_db;
    int _port;
    std::string _master_host;
    boost::shared_ptr<TTransport> _transport;
    ReplicationClient* _client;
    int _sync_interval = 1;
    bool _running = true;

public:
    ReplicationSlave(DB *db, std::string master_host, int port) { 
        _db          = db;
        _port        = port;
        _master_host = master_host;
    }

    void Update() throw () { 
        try {
            while(_running) {
                std::string data;
                SequenceNumber last_seq = _db->GetLatestSequenceNumber();
                _client->Update(data, last_seq);
                WriteBatch wb = WriteBatch(data);
                Status s = _db->Write(WriteOptions(), &wb);
                if(!s.ok()) {
                    std::cout << std::endl;
                }
                std::cout << last_seq <<":"<< data << std::endl;
            }
        } catch (ReplicationError& e) {
            if(e.what == 0) {
                _running = false;
                throw e;
            }
        }
    }

    void Sync() {
        while(_running) {
            Update();
            sleep(_sync_interval);
        }
    }

    void StartReplication() {
        boost::shared_ptr<TTransport> socket(new TSocket(_master_host, _port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol>  protocol(new TBinaryProtocol(transport));
        _client = new ReplicationClient(protocol);
        _transport = transport;
        _running   = true;

        try {
            transport->open();
            std::thread replication_thread = std::thread(&ReplicationSlave::Sync, std::ref(*this));
            replication_thread.detach();
        } catch (TException& tx) {
            std::cout << "ERROR: " << tx.what() << std::endl;
        }
    }

    Status StopReplication() {
        _running = false;
        _transport->close();
        return Status::OK();
    }
    
    ~ReplicationSlave() {
        StopReplication();
    }
};

int main(int argc, char **argv) {
    DB *_slave;
    Options options;
    options.IncreaseParallelism();
    options.OptimizeLevelStyleCompaction();
    options.create_if_missing = true;
    std::string kDBPath = "/tmp/rocksdb_custom_slave1";
    Status st = DB::Open(options, kDBPath, &_slave);

    ReplicationSlave slave(_slave, "localhost", 9090);
    std::cout << "start replication" << std::endl;
    slave.StartReplication();
    sleep(10);
    
    return 0;
}

